# 虚拟文件系统 - VFS 

每个程序都是线性的、逻辑的虚拟地址，通过MRU转到CPU物理地址，一个程序想要获取IO中数据时，一般通过内核调用IO数据，当然程序也可以直接获取IO数据

内核包含哪些内容？

- VFS 目录树结构。树上不同节点可以映射到不同的物理位置，每个物理位置可以是不同的、具体的文件系统。比如网络上的节点。windows属于物理文件系统。VFS可以想象成暴露给用户空间的a统一接口，实现以及驱动可以不一样。每个程序都是FD，通过seek指针，也就是偏移量找到自己该读写的pagecache，修改同一数据会加锁
  - inode，可以抽象成id。每个文件都有一个inode号，inode号在内存里
  - pagecache，页缓存，默认4K。
    - 一个程序想要读数据，通常默认的是第一步访问内核，告诉内核需要加载哪个文件，inode号被加载，元数据被加载，先由内核去读，读到内存里面，开辟一个pagecache。
    - 两个程序想打开同一个文件，pagecache会让共享出来
    - dirty，程序读取了磁盘里文件到pagecache，然后程序改了某个pagecache中的数据，修改过的pagecache被标记为dirty
    - flush，将标记为dirty的pagecache刷新到磁盘中。可以交由内核在特定时间刷新到磁盘，也可以在修改完后立即让内核刷新到磁盘

**实际操作**

*查看虚拟目录树结构*

```shell
# Linux有3个分区，sda1 BIOS时加载、swap 交换分区、sda3 root分区
cd /
df #linux中df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。boot目录是属于sda3，但是sda1覆盖了sda3
df -h #方便阅读方式显示
cd /boot/ #包含内核的镜像
cd /
umount /boot #卸载boot，删除sda1分区的boot目录，还有boot目录，此时的目录是sda3分区的
mount /dev/sdal /boot #将sda1挂载到root目录
# 卸载、挂载对程序没有影响。因为目录树的结构趋向于稳定，有一个映射的过程
```

*文件类型*

> 首先得知道冯诺依曼体系
>
> 计算器、控制器 - CPU
>
> 主存储器 - 内存
>
> 输入输出设备 - I/O
>
>  
>
> Linux将其抽象成 <span style='color:red'>一切皆文件</span>



